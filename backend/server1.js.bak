// server.js
const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const { parse } = require('csv-parse/sync');
 // synchronous CSV parse

const app = express();
app.use(cors());
app.use(express.json());

const TOTAL_CANDIDATES = 1800000; // change later with accurate number
const DATA_PATH = path.join(__dirname, 'data', 'score_percentile.csv');

// load CSV once at startup
let percentileTable = loadCSV(DATA_PATH); // array of {score, percentile} sorted desc by score

function loadCSV(filepath){
  if(!fs.existsSync(filepath)) {
    console.error('CSV not found at', filepath);
    return [];
  }
  const raw = fs.readFileSync(filepath, 'utf8');
  const records = parse(raw, {columns: true, trim: true});
  // convert types and sort descending by score
  const table = records.map(r=>({
    score: Number(r.score),
    percentile: Number(r.percentile)
  })).sort((a,b)=>b.score - a.score);
  return table;
}

// Linear interpolation: given score, return percentile.
// If score higher than highest sample -> return highest percentile.
// If lower than lowest sample -> linear extrapolate toward 0 (or floor at 0).
function estimatePercentileFromTable(score){
  if(!percentileTable || percentileTable.length === 0) {
    return null;
  }
  const table = percentileTable;
  // exact match
  for(const row of table){
    if(score === row.score) return row.percentile;
  }
  // above highest score
  if(score > table[0].score) return table[0].percentile;
  // below lowest score: linear down to 0
  const last = table[table.length - 1];
  if(score < last.score) {
    // simple extrapolate proportionally
    const pct = Math.max(0, (score / last.score) * last.percentile);
    return pct;
  }
  // find interval and interpolate
  for(let i=0;i<table.length-1;i++){
    const hi = table[i];
    const lo = table[i+1];
    if(score < hi.score && score > lo.score){
      // linear interpolation
      const t = (score - lo.score) / (hi.score - lo.score); // 0..1 between lo and hi
      const pct = lo.percentile + t * (hi.percentile - lo.percentile);
      return pct;
    } else if(score === lo.score) {
      return lo.percentile;
    }
  }
  // fallback
  return table[table.length-1].percentile;
}

function percentileToRank(percentile){
  const p = Math.min(Math.max(percentile, 0), 99.999);
  const rank = Math.round(TOTAL_CANDIDATES * (100 - p) / 100);
  return Math.max(1, rank);
}

// load correction factors (category & state)
let corrections = { categories: {}, states: {} };
const CORR_PATH = path.join(__dirname, 'data', 'corrections.json');
if(fs.existsSync(CORR_PATH)) {
  try { corrections = JSON.parse(fs.readFileSync(CORR_PATH, 'utf8')); }
  catch(e){ console.warn('Invalid corrections.json'); }
}
// --- colleges loading ---------------------------------------------------
const COLLEGE_PATH = path.join(__dirname, 'data', 'colleges.csv');
let colleges = [];

// load colleges CSV (if exists)
function loadColleges() {
  try {
    if (!fs.existsSync(COLLEGE_PATH)) {
      console.warn('No colleges.csv found at', COLLEGE_PATH);
      colleges = [];
      return;
    }
    const raw = fs.readFileSync(COLLEGE_PATH, 'utf8');
    const rows = parse(raw, { columns: true, trim: true });
    // normalize into expected shape and numeric fields
    colleges = rows.map(r => ({
      college: r.college,
      category: r.category || 'All',
      seats: Number((r.seats || '').toString().replace(/,/g, '')) || 0,
      min_rank: Number((r.min_rank || '').toString().replace(/,/g, '')) || Number.POSITIVE_INFINITY,
      max_rank: Number((r.max_rank || '').toString().replace(/,/g, '')) || Number.POSITIVE_INFINITY,
      fees_per_year: Number((r.fees_per_year || '').toString().replace(/,/g, '')) || null
    }));
    console.log('Loaded colleges:', colleges.length);
    console.log('DEBUG: colleges preview:', colleges.slice(0, 10));
  } catch (e) {
    console.warn('Failed to load colleges.csv:', e.message || e);
    colleges = [];
  }
}

// initial load
loadColleges();
// --- suggest colleges by rank -------------------------------------------
function suggestCollegesByRank(rank, limit = 5) {
  if (!colleges || colleges.length === 0) return [];

  const normalized = colleges.map(c => ({
    ...c,
    min_rank: Number(c.min_rank) || Number.POSITIVE_INFINITY,
    max_rank: Number(c.max_rank) || Number.POSITIVE_INFINITY
  }));

  const exact = normalized.filter(c => rank >= c.min_rank && rank <= c.max_rank);
  if (exact.length > 0) {
    return exact.slice(0, limit).map(c => ({ ...c, likelihood: 100 }));
  }

  // compute distance and approximate likelihood:
  const withScore = normalized.map(c => {
    let distance;
    if (rank < c.min_rank) distance = c.min_rank - rank;
    else if (rank > c.max_rank) distance = rank - c.max_rank;
    else distance = 0;

    // heuristic for likelihood: wider ranges => lower max likelihood; closer => higher
    const rangeSize = Math.max(1, c.max_rank - c.min_rank);
    // convert distance -> score: closer => higher. Cap influence by range
    const raw = Math.max(0, 1 - (distance / (rangeSize * 2 + 1))); // -inf..1
    const likelihood = Math.round(Math.min(100, raw * 100));
    return { ...c, distance, likelihood };
  });

  return withScore.sort((a, b) => a.distance - b.distance).slice(0, limit);
}


// Replace your existing /api/predict route with this block
app.post('/api/predict', (req, res) => {
  const { score, category = 'General', state = 'Default' } = req.body;
  if (score == null) return res.status(400).json({ error: 'score required' });

  const pctRaw = estimatePercentileFromTable(Number(score));
  if (pctRaw == null) return res.status(500).json({ error: 'percentile table not loaded' });

  const pctCorrected = applyCorrections(pctRaw, category, state);
  const rank = percentileToRank(pctCorrected);

  // get college suggestions (ensure suggestCollegesByRank exists)
  let collegesSuggested = [];
  try {
    if (typeof suggestCollegesByRank === 'function') {
      collegesSuggested = suggestCollegesByRank(rank, 10); // return up to 10 suggestions
    }
  } catch (e) {
    console.warn('Error suggesting colleges:', e && e.message ? e.message : e);
    collegesSuggested = [];
  }

  res.json({
    score: Number(score),
    estimated_percentile_raw: Number(pctRaw.toFixed(3)),
    estimated_percentile_corrected: Number(pctCorrected.toFixed(3)),
    estimated_rank: rank,
    colleges_suggested: collegesSuggested,
    note: 'CSV interpolation used. Replace data files with actual historic tables for higher accuracy.'
  });
});


// Apply simple corrections: either multiplier on percentile or offset
function applyCorrections(percentile, category, state){
  let p = percentile;
  if(category && corrections.categories && corrections.categories[category]){
    const c = corrections.categories[category];
    if(c.mode === 'add') p += c.value;
    else if(c.mode === 'mul') p *= c.value;
  }
  if(state && corrections.states && corrections.states[state]){
    const s = corrections.states[state];
    if(s.mode === 'add') p += s.value;
    else if(s.mode === 'mul') p *= s.value;
  }
  // clamp
  return Math.min(99.999, Math.max(0, p));
}

// API
app.post('/api/predict', (req, res) => {
  const { score, category, state } = req.body;
  if(score == null) return res.status(400).json({error:'score required'});
  const pctRaw = estimatePercentileFromTable(Number(score));
  if(pctRaw == null) return res.status(500).json({error:'percentile table not loaded'});
  const pctCorrected = applyCorrections(pctRaw, category, state);
  const rank = percentileToRank(pctCorrected);

  res.json({
    score: Number(score),
    estimated_percentile_raw: Number(pctRaw.toFixed(3)),
    estimated_percentile_corrected: Number(pctCorrected.toFixed(3)),
    estimated_rank: rank,
    note: 'CSV interpolation used. Replace data files with actual historic tables for higher accuracy.'
  });
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, ()=> console.log(`Backend running on port ${PORT}`));
