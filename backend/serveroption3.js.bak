// server.js
const express = require('express');
const cors = require('cors');
const fs = require('fs');
const path = require('path');
const { parse } = require('csv-parse/sync');
 // synchronous CSV parse

const app = express();
app.use(cors());
app.use(express.json());

const TOTAL_CANDIDATES = 1800000; // change later with accurate number
const DATA_PATH = path.join(__dirname, 'data', 'score_percentile.csv');

// load CSV once at startup
let percentileTable = loadCSV(DATA_PATH); // array of {score, percentile} sorted desc by score

function loadCSV(filepath){
  if(!fs.existsSync(filepath)) {
    console.error('CSV not found at', filepath);
    return [];
  }
  const raw = fs.readFileSync(filepath, 'utf8');
  const records = parse(raw, {columns: true, trim: true});
  // convert types and sort descending by score
  const table = records.map(r=>({
    score: Number(r.score),
    percentile: Number(r.percentile)
  })).sort((a,b)=>b.score - a.score);
  return table;
}

// Linear interpolation: given score, return percentile.
// If score higher than highest sample -> return highest percentile.
// If lower than lowest sample -> linear extrapolate toward 0 (or floor at 0).
function estimatePercentileFromTable(score){
  if(!percentileTable || percentileTable.length === 0) {
    return null;
  }
  const table = percentileTable;
  // exact match
  for(const row of table){
    if(score === row.score) return row.percentile;
  }
  // above highest score
  if(score > table[0].score) return table[0].percentile;
  // below lowest score: linear down to 0
  const last = table[table.length - 1];
  if(score < last.score) {
    // simple extrapolate proportionally
    const pct = Math.max(0, (score / last.score) * last.percentile);
    return pct;
  }
  // find interval and interpolate
  for(let i=0;i<table.length-1;i++){
    const hi = table[i];
    const lo = table[i+1];
    if(score < hi.score && score > lo.score){
      // linear interpolation
      const t = (score - lo.score) / (hi.score - lo.score); // 0..1 between lo and hi
      const pct = lo.percentile + t * (hi.percentile - lo.percentile);
      return pct;
    } else if(score === lo.score) {
      return lo.percentile;
    }
  }
  // fallback
  return table[table.length-1].percentile;
}

function percentileToRank(percentile){
  const p = Math.min(Math.max(percentile, 0), 99.999);
  const rank = Math.round(TOTAL_CANDIDATES * (100 - p) / 100);
  return Math.max(1, rank);
}

// load correction factors (category & state)
let corrections = { categories: {}, states: {} };
const CORR_PATH = path.join(__dirname, 'data', 'corrections.json');
if(fs.existsSync(CORR_PATH)) {
  try { corrections = JSON.parse(fs.readFileSync(CORR_PATH, 'utf8')); }
  catch(e){ console.warn('Invalid corrections.json'); }
}
// --- colleges loading ---------------------------------------------------
const COLLEGE_PATH = path.join(__dirname, 'data', 'colleges.csv');
let colleges = [];

// load colleges CSV (if exists)
function loadColleges() {
  try {
    if (!fs.existsSync(COLLEGE_PATH)) {
      console.warn('No colleges.csv found at', COLLEGE_PATH);
      colleges = [];
      return;
    }
    const raw = fs.readFileSync(COLLEGE_PATH, 'utf8');
    const rows = parse(raw, { columns: true, trim: true });
    // normalize into expected shape and numeric fields
    colleges = rows.map(r => ({
      college: r.college,
      category: r.category || 'All',
      seats: Number((r.seats || '').toString().replace(/,/g, '')) || 0,
      min_rank: Number((r.min_rank || '').toString().replace(/,/g, '')) || Number.POSITIVE_INFINITY,
      max_rank: Number((r.max_rank || '').toString().replace(/,/g, '')) || Number.POSITIVE_INFINITY,
      fees_per_year: Number((r.fees_per_year || '').toString().replace(/,/g, '')) || null
    }));
    console.log('Loaded colleges:', colleges.length);
    console.log('DEBUG: colleges preview:', colleges.slice(0, 10));
  } catch (e) {
    console.warn('Failed to load colleges.csv:', e.message || e);
    colleges = [];
  }
}

// initial load
loadColleges();
// --- suggest colleges by rank -------------------------------------------
// Improved suggestion with quota & likelihood
// Requires `colleges` to be an array of objects loaded from colleges.csv
// Each college object MAY include category_seats like { General:100, OBC:30, SC:15 } (optional)
function suggestCollegesByRank(rank, { category='General', state='Default', limit=7 } = {}) {
  if (!colleges || colleges.length === 0) return [];

  // Normalize numeric fields
  const normalized = colleges.map(c => ({
    ...c,
    min_rank: Number(c.min_rank) || Number.POSITIVE_INFINITY,
    max_rank: Number(c.max_rank) || Number.POSITIVE_INFINITY,
    seats: Number(c.seats) || 0,
    // optional: category_seats stored as JSON string in CSV -> parse if present
    category_seats: typeof c.category_seats === 'string' ? tryParseJSON(c.category_seats) : c.category_seats || {}
  }));

  // Helper: fallback parser
  function tryParseJSON(s) {
    try { return JSON.parse(s); } catch(e){ return {}; }
  }

  // Score each college
  const scored = normalized.map(c => {
    // is exact fit?
    const inside = rank >= c.min_rank && rank <= c.max_rank;

    // distance to nearest boundary (0 if inside)
    let distance = 0;
    if (!inside) {
      if (rank < c.min_rank) distance = c.min_rank - rank;
      else distance = rank - c.max_rank;
    }

    // effective seats for category (fallback to total seats)
    let effectiveSeats = c.seats;
    if (c.category_seats && c.category_seats[category] != null) {
      const v = Number(c.category_seats[category]);
      if (!isNaN(v) && v > 0) effectiveSeats = v;
    }

    // range size (use at least 1)
    const rangeSize = Math.max(1, c.max_rank - c.min_rank + 1);

    // Heuristic likelihood:
    // - If inside range => base = 0.8..1.0 depending on how close to center of range and seats
    // - If outside => base decreases with distance relative to rangeSize
    let base;
    if (inside) {
      // closeness to range center (0..1)
      const center = (c.min_rank + c.max_rank) / 2;
      const closeness = 1 - (Math.abs(rank - center) / (rangeSize/2 + 1));
      base = 0.75 + 0.25 * closeness; // 0.75..1.0 inside
    } else {
      // outside: farther distance => smaller base; scale by rangeSize so wide ranges are more forgiving
      base = Math.max(0, 1 - (distance / (rangeSize * 2 + 1)));
      base *= 0.6; // outside ranks less confident
    }

    // adjust with seats (more seats slightly raise likelihood)
    const seatFactor = 1 + Math.min(0.5, effectiveSeats / 500); // caps effect
    let likelihood = Math.round(Math.min(100, base * seatFactor * 100));

    // provide reason
    const reason = inside ? 'In range' : `Nearest by ${distance.toLocaleString()} ranks`;

    return { ...c, distance, rangeSize, effectiveSeats, likelihood, reason };
  });

  // Sort: prefer higher likelihood and closer distance, then smaller fees (if present)
  scored.sort((a,b) => {
    if (b.likelihood !== a.likelihood) return b.likelihood - a.likelihood;
    if (a.distance !== b.distance) return a.distance - b.distance;
    return (Number(a.fees_per_year)||0) - (Number(b.fees_per_year)||0);
  });

  // Limit and return only required fields
  const res = scored.slice(0, limit).map(c => ({
    college: c.college,
    category: c.category,
    seats: c.seats,
    min_rank: c.min_rank,
    max_rank: c.max_rank,
    fees_per_year: c.fees_per_year,
    effectiveSeats: c.effectiveSeats,
    likelihood: c.likelihood,
    reason: c.reason
  }));

  return res;
}


// Replace your existing /api/predict route with this block
app.post('/api/predict', (req, res) => {
  const { score, category = 'General', state = 'Default' } = req.body;
  if (score == null) return res.status(400).json({ error: 'score required' });

  const pctRaw = estimatePercentileFromTable(Number(score));
  if (pctRaw == null) return res.status(500).json({ error: 'percentile table not loaded' });

  const pctCorrected = applyCorrections(pctRaw, category, state);
  const rank = percentileToRank(pctCorrected);

  // get college suggestions (ensure suggestCollegesByRank exists)
  let collegesSuggested = [];
  try {
    if (typeof suggestCollegesByRank === 'function') {
      collegesSuggested = suggestCollegesByRank(rank, 10); // return up to 10 suggestions
    }
  } catch (e) {
    console.warn('Error suggesting colleges:', e && e.message ? e.message : e);
    collegesSuggested = [];
  }

  res.json({
    score: Number(score),
    estimated_percentile_raw: Number(pctRaw.toFixed(3)),
    estimated_percentile_corrected: Number(pctCorrected.toFixed(3)),
    estimated_rank: rank,
    colleges_suggested: collegesSuggested,
    note: 'CSV interpolation used. Replace data files with actual historic tables for higher accuracy.'
  });
});


// Apply simple corrections: either multiplier on percentile or offset
function applyCorrections(percentile, category, state){
  let p = percentile;
  if(category && corrections.categories && corrections.categories[category]){
    const c = corrections.categories[category];
    if(c.mode === 'add') p += c.value;
    else if(c.mode === 'mul') p *= c.value;
  }
  if(state && corrections.states && corrections.states[state]){
    const s = corrections.states[state];
    if(s.mode === 'add') p += s.value;
    else if(s.mode === 'mul') p *= s.value;
  }
  // clamp
  return Math.min(99.999, Math.max(0, p));
}

// API
app.post('/api/predict', (req, res) => {
  const { score, category, state } = req.body;
  if(score == null) return res.status(400).json({error:'score required'});
  const pctRaw = estimatePercentileFromTable(Number(score));
  if(pctRaw == null) return res.status(500).json({error:'percentile table not loaded'});
  const pctCorrected = applyCorrections(pctRaw, category, state);
  const rank = percentileToRank(pctCorrected);

  res.json({
    score: Number(score),
    estimated_percentile_raw: Number(pctRaw.toFixed(3)),
    estimated_percentile_corrected: Number(pctCorrected.toFixed(3)),
    estimated_rank: rank,
    note: 'CSV interpolation used. Replace data files with actual historic tables for higher accuracy.'
  });
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, ()=> console.log(`Backend running on port ${PORT}`));
